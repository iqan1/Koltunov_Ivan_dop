# Колтунов Иван 4341 ООП Доп. задания


## Оглавление
1. [Task 1: Генератор (SimpleRNG)]
2. [Task 2: Маска (Mask)]
3. [Task 3: Менеджер памяти (MemReserver)]
4. [Task 5: Пайплайн (Pipeline)]



## Task 1: SimpleRNG
**Директория:** `Task1_SimpleRNG`

### Описание задачи
Реализация генератора псевдослучайных чисел на основе **Линейного Конгруэнтного Метода** с поддержкой итераторов STL (`InputIterator`).

### Как это сделано
1. **Алгоритм:** Используется формула $X_{n+1} = (a \cdot X_n + c) \pmod m$. Поскольку работа идет с типом `double`, вместо оператора `%` использована функция `std::fmod`.
2. **Итератор:** Реализован вложенный класс `Iterator`, удовлетворяющий требованиям `std::input_iterator_tag`.
   - **Инкремент (`operator++`):** Не перемещает указатель по памяти, а вычисляет новое состояние генератора по формуле.
   - **Сравнение (`operator==`):** Реализована логика сравнения с `end(eps)`. Итератор считается достигшим конца, если текущее значение генератора вернулось к начальному (цикл замкнулся) с заданной точностью `eps`.
3. **Безопасность:** В демонстрации (`main.cpp`) добавлен механизм защиты от бесконечного цикла (ограничение по количеству шагов), так как при определенных параметрах $a < 1$ математический цикл может быть бесконечным.



## Task 2: Mask
**Директория:** `Task2_Mask`

### Описание задачи
Шаблонный класс `Mask<N>`, позволяющий фильтровать и преобразовывать контейнеры на основе битовой маски (1/0).

### Как это сделано
1. **Валидация:** Используются **Variadic Templates** и `static_assert` в конструкторе. Это гарантирует на этапе компиляции, что количество переданных элементов маски строго совпадает с шаблонным параметром `N`.
2. **Цикличность:** Если размер обрабатываемого контейнера больше размера маски, маска применяется циклично. Это реализовано через арифметику остатков: доступ к маске осуществляется по индексу `i % N`.
3. **Методы:**
   - `slice`: Модифицирует контейнер in-place, удаляя элементы, где маска равна 0 (используется идиома erase-remove логики).
   - `transform`: Создает новый контейнер, применяя функтор к элементам, где маска равна 1.
   - `slice_and_transform`: Комбинация фильтрации и трансформации.


## Task 3: MemReserver
**Директория:** `Task3_MemReserver`

### Описание задачи
Класс для управления статической памятью под фиксированное количество объектов `N` без использования динамической кучи (heap) и STL-контейнеров.

### Как это сделано
1. **Хранение:** Используется массив структур `Slot`, содержащий "сырой" буфер `unsigned char data[sizeof(T)]` с выравниванием `alignas(T)`. Это позволяет хранить объекты непосредственно внутри класса `MemReserver`.
2. **Placement New:** Метод `create` использует конструкцию `new (ptr) T(...)` для создания объекта в заранее выделенном буфере.
3. **Ручное управление жизнью:**
   - Деструкторы объектов вызываются явно (`ptr->~T()`) при вызове метода `delete` или при уничтожении самого резервуара.
   - Отслеживается статус занятости слотов (`is_active`).
4. **Обработка ошибок:** Реализованы собственные классы исключений для ситуаций переполнения (`NotEnoughSlotsError`) или доступа к пустому слоту.


## Task 5: Pipeline
**Директория:** `Task5_Pipeline`

### Описание задачи
Система организации вычислений в виде конвейера (пайплайна) с использованием оператора `|`. Поддерживает ленивые (lazy) вычисления.

### Как это сделано
1. **Перегрузка оператора `|`:** Глобальные шаблонные операторы связывают данные и функции в цепочку узлов `PipelineNode`.
2. **PipelineNode:** Класс-обертка, который хранит предыдущий шаг вычисления и текущую операцию.
3. **Стратегии выполнения:**
   - **Ленивое вычисление:** Если результат `operator|` сохранен в переменную, вычисления не запускаются. Они происходят только при явном вызове `pipeline()`.
   - **Немедленное вычисление:** Если пайплайн создан как временный объект (r-value), деструктор `PipelineNode` автоматически запускает цепочку вычислений.

   [Для запуска программ в папке с программой нужно прописать: "g++ main.cpp -o app"]

